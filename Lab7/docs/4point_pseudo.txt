// reg[0] is where the products are accumulated
// reg[1]-reg[4] holds the last 4 samples, with reg[1] being the oldest
// reg[5] is where the new sample is copied to
// reg[6]-reg[9] is where the coefficients are stored, with reg[6] holding F3
// reg[10] is used as intermediate storage space for operations

idle:  if (data_ready = 0) goto idle;    // wait until data_ready == 1
store: if (data_ready = 0) goto eidle;
       reg[5]  = data;                   // store data in a register
       err     = 0;                      // reset error
zero:  reg[0]  = 0;                      // zero out accumulator
sort1: reg[1]  = reg[2];                 // reorder registers
sort2: reg[2]  = reg[3];                 // reorder registers
sort3: reg[3]  = reg[4];                 // reorder registers
sort4: reg[4]  = reg[5];                 // reorder registers
mul1:  reg[10] = reg[1] * reg[6]         // sample4 * F3
add1:  reg[0]  = reg[0] + reg[10]        // add product
       if (V) goto eidle;                // on overflow, err condition
mul2:  reg[10] = reg[2] * reg[7]         // sample3 * F2
sub1:  reg[0]  = reg[0] - reg[10]        // sub product
       if (V) goto eidle;                // on overflow, err condition
mul3:  reg[10] = reg[3] * reg[8]         // sample2 * F1
add2:  reg[0]  = reg[0] + reg[10]        // add product
       if (V) goto eidle;                // on overflow, err condition
mul4:  reg[10] = reg[4] * reg[9]         // sample1 * F0
sub2:  reg[0]  = reg[0] - reg[10]        // sub product
       if (V) goto eidle;                // on overflow, err condition
       else goto idle;
eidle: err = 1;
       if (data_ready = 1) goto store;   // wait until data_ready = 1
       if (data_ready = 0) goto eidle;